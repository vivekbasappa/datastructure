import time 
import datetime
from random import randrange


# Sequence Generator
class Sequence(object):
	def __init__(self):
		self.counter = 0
	
	def __iter__(self):
		while True:
			yield self.counter 
			if self.counter >= 4096:
				self.counter = 0
			self.counter += 1

class GlobalId(object):
	# assuming that million records are generated by single node
	# 41 bits : Timestamp, The standard Epoch for time is January 1st, 1970. So 
	# 				  it takes 41 bits of a long to represent the number of 
	#  				  milliseconds since the Epoch
	# 11 bits : Node ID, 1024 in binary is 10000000000. 
	#  					We have used 11 bits to represent 1024 in binary.
	# 12 bits sequence number : sequence 4096
	NODE_ID_BITS = 11 # Node ID maximu 1024
	MAX_NODE_ID = -1 ^ (-1 << NODE_ID_BITS)  # Mask for Node ID set
	SEQUENCE_BITS = 12  # 12 bit for Sequence
	SEQUENCE_MAKS = -1 ^ (-1 << SEQUENCE_BITS)

	NODE_ID_SHIFT = SEQUENCE_BITS
	TIMESTAMP_LEFT_SHIFT = SEQUENCE_BITS + NODE_ID_BITS
	EPOC = datetime.datetime.utcfromtimestamp(0) 

	def __init__(self):
		self.last_timestamp = -1 # initital value set to -1
		self.SequenceIter = iter(Sequence())  
		self.sequence = next(self.SequenceIter) & GlobalId.SEQUENCE_MAKS # generate first sequence to be used

	# get_id used in get unique id 
	# arguments node_id
	# return: 
	# 		Unique Id combination of timestamp + node_id + sequence
	def get_id(self, node_id):

		# validation for node id if its more than 4096
		if node_id > GlobalId.MAX_NODE_ID:
			raise Exception("node id is more than max node id allowed")

		timestamp = self.get_current_time_milliseconds()

	  # if timestamp is less than last_timestamp we processed then throw error
		if timestamp < self.last_timestamp:
			raise Exception("time has skew")

		# if we are processing at the same milli second time, then use sequence to get new number
		# assuming that the sequence can process 4096 request not more than that for given node
		# if sequence is reset to 0 after 4096 then wait until the time changes to next milli second
		if self.last_timestamp == timestamp:
			self.sequence = next(self.SequenceIter) & GlobalId.SEQUENCE_MAKS
			if self.sequence == 0:
				timestamp = self.wait_until_next_milliseconds(self.last_timestamp)

		# assign last time stamp to timestamp we used in processing	
		self.last_timestamp = timestamp
		# result is combination of timestamp , node_id , sequence
		result = timestamp << GlobalId.TIMESTAMP_LEFT_SHIFT | ( self.get_node_id() << GlobalId.NODE_ID_SHIFT) | self.sequence
		return result

  # just for simiplilfy generating random node ids 
	def get_node_id(self): 
		return randrange(1024)

  # if the current timestamp is less than the last processed timestamp, loop until 
	# timestamp is greater
	def wait_until_next_milliseconds(self, last_timestamp):
		timestamp = self.get_current_time_milliseconds()
		while timestamp <= self.last_timestamp:
			timestamp = self.get_current_time_milliseconds()
		return timestamp

  # get current time in milliseconds
	def get_current_time_milliseconds(self):
		dt = datetime.datetime.now()
		return round((dt - self.EPOC).total_seconds() * 1000.0)

if __name__ == "__main__":
	globalId = GlobalId()
	while True:
		node_id = globalId.get_node_id()
		print("node: ", node_id, ", uuid:", globalId.get_id(node_id))
